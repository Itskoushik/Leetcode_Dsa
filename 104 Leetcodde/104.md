Maximum Depth of a Binary Tree

Problem Statement

The function maxDepth calculates the maximum depth (or height) of a binary tree. The depth of a binary tree is the number of nodes along the longest path from the root node down to the farthest leaf node.

Approach

The approach used in this solution is recursion:

If the root is None, return 0 (base case for an empty tree).

Recursively find the depth of the left and right subtrees.

The maximum depth is 1 + max(left_depth, right_depth) because we count the current node plus the maximum depth of its subtrees.

Code Explanation

class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        # Base case: If the tree is empty, return depth as 0
        if not root:
            return 0
        
        # Recursive case: Find the maximum depth between left and right subtrees
        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))

Explanation:

Base Case:

If root is None, return 0 since an empty tree has no depth.

Recursive Case:

Recursively compute the maximum depth of the left and right subtrees.

Use max(self.maxDepth(root.left), self.maxDepth(root.right)) to get the deeper subtree.

Add 1 to account for the current node.

Complexity Analysis

Time Complexity: O(N), where N is the number of nodes in the tree (each node is visited once).

Space Complexity: O(H), where H is the height of the tree (due to recursive call stack).

In a balanced tree, H = log N (better space efficiency).

In a skewed tree (like a linked list), H = N (worst case scenario).

Example Walkthrough

Consider the binary tree:

       1
      / \
     2   3
    / \    \
   4   5    6

Function calls:

maxDepth(1) -> 1 + max(maxDepth(2), maxDepth(3))
maxDepth(2) -> 1 + max(maxDepth(4), maxDepth(5))
maxDepth(3) -> 1 + max(0, maxDepth(6))
maxDepth(4) -> 1 (leaf node)
maxDepth(5) -> 1 (leaf node)
maxDepth(6) -> 1 (leaf node)

Final result: maxDepth(1) = 3.
