# ðŸ“Œ LeetCode #153: Find Minimum in Rotated Sorted Array 
ðŸ”— **Problem Link:** [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)  

## ðŸš€ Problem Statement  ðŸŸ¡ **Difficulty:** Medium
Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:

[4,5,6,7,0,1,2] if it was rotated 4 times.
[0,1,2,4,5,6,7] if it was rotated 7 times.
Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].

Given the sorted rotated array nums of unique elements, return the minimum element of this array.

You must write an algorithm that runs in O(log n) time.

### ðŸ”¹ Example 1:  
```python
Input: nums = [3,4,5,1,2]
Output: 1
Explanation: The original array was [1,2,3,4,5] rotated 3 times.
```
### ðŸ”¹ Example 2:  

```python
Input: nums = [4,5,6,7,0,1,2]
Output: 0
Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.
```
### ðŸ”¹ Example 3:  

```python
Input: nums = [11,13,15,17]
Output: 11
Explanation: The original array was [11,13,15,17] and it was rotated 4 times.
```
Constraints:
```
n == nums.length
1 <= n <= 5000
-5000 <= nums[i] <= 5000

```
All the integers of nums are unique.
nums is sorted and rotated between 1 and n times.

 ## ðŸš€ Solution Explanation  
 Approach

Brute Force (O(n))

One naive way to solve this problem is by iterating through the entire array and returning the minimum value. However, this approach takes O(n) time, which is not optimal.

Optimized Approach: Binary Search (O(log n))

Since the array is sorted but rotated, we can use binary search to efficiently locate the minimum element in O(log n) time.

Algorithm

Initialize two pointers: left = 0 and right = len(nums) - 1.

Perform binary search:

Calculate mid = (left + right) // 2.

If nums[mid] > nums[right], it means the smallest element is in the right half (since the left half is sorted, and mid is not the smallest). So, update left = mid + 1.

Otherwise, the smallest element is in the left half or at mid itself. So, update right = mid.

When the loop terminates, left and right will point to the minimum element.

Return nums[left], as it is the minimum element in the array.




  

 
